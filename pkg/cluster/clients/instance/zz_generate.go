//go:build ignore
// +build ignore

/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generate GenerateUpdateApplicationSettingsOptions and GenerateApplicationSettingsObservation type converters
//go:generate go run generate.go

// Code generated by hack/generate-cluster-scope.go - DO NOT EDIT.

package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/crossplane-contrib/provider-gitlab/apis/cluster/instance/v1alpha1"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

const outputHeader = `/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by generate.go. DO NOT EDIT.

package instance

import (
	"strings"

	"github.com/crossplane-contrib/provider-gitlab/apis/cluster/instance/v1alpha1"
	"github.com/crossplane-contrib/provider-gitlab/pkg/cluster/clients"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)
`

var funcTemplate = template.Must(template.New("funcs").Parse(`
// GenerateUpdateApplicationSettingsOptions generates GitLab Settings update options from the desired state
// This function is generated by ApplicationSettingsParameters and gitlab.UpdateSettingsOptions reflection
func GenerateUpdateApplicationSettingsOptions(p *v1alpha1.ApplicationSettingsParameters) *gitlab.UpdateSettingsOptions {
	if p == nil {
		return nil
	}
	o := &gitlab.UpdateSettingsOptions{}
{{- range .UpdateFields }}
	{{ . }}
{{- end }}
	return o
}

// GenerateApplicationSettingsObservation generates GitLab Settings observation from the actual state
// This function is generated by ApplicationSettingsObservation and gitlab.Settings reflection
func GenerateApplicationSettingsObservation(g *gitlab.Settings) v1alpha1.ApplicationSettingsObservation {
	if g == nil {
		return v1alpha1.ApplicationSettingsObservation{}
	}
	o := v1alpha1.ApplicationSettingsObservation{}
{{- range .ObservationFields }}
	{{ . }}
{{- end }}
	return o
}

// IsApplicationSettingsUpToDate checks whether the observed state matches the desired state
// This function is generated by ApplicationSettingsParameters and gitlab.Settings reflection
func IsApplicationSettingsUpToDate(p *v1alpha1.ApplicationSettingsParameters, g *gitlab.Settings) bool {
	if p == nil {
		return true
	}
	if g == nil {
		return false
	}
{{- range .UpToDateFields }}
	{{ . }}
{{- end }}
	return true
}

// LateInitializeApplicationSettings fills the empty fields in the application settings spec with the
// values seen in gitlab.Settings.
// This function is generated by ApplicationSettingsParameters and gitlab.Settings reflection
func LateInitializeApplicationSettings(in *v1alpha1.ApplicationSettingsParameters, settings *gitlab.Settings) {
	if settings == nil {
		return
	}
{{- range .LateInitializeFields }}
	{{ . }}
{{- end }}
}
`))

type Data struct {
	UpdateFields         []string
	ObservationFields    []string
	UpToDateFields       []string
	LateInitializeFields []string
}

func main() {
	data := Data{}

	// Generate Update fields
	updateType := reflect.TypeOf(gitlab.UpdateSettingsOptions{})
	v1UpdateType := reflect.TypeOf(v1alpha1.ApplicationSettingsParameters{})
	for i := 0; i < updateType.NumField(); i++ {
		field := updateType.Field(i)
		fieldName := field.Name

		// Find corresponding field in v1alpha1
		v1Field, found := v1UpdateType.FieldByName(fieldName)
		if !found {
			// Try to find by checking JSON tag or similar if needed, but usually names match
			// In v1alpha1 generator, we used fieldName directly.
			// Let's assume names match.
			continue
		}

		// Generate assignment code
		code := generateUpdateAssignment(fieldName, field.Type, v1Field.Type)
		if code != "" {
			data.UpdateFields = append(data.UpdateFields, code)
		}
	}

	// Generate Observation fields
	obsType := reflect.TypeOf(gitlab.Settings{})
	v1ObsType := reflect.TypeOf(v1alpha1.ApplicationSettingsObservation{})
	for i := 0; i < obsType.NumField(); i++ {
		field := obsType.Field(i)
		fieldName := field.Name

		v1Field, found := v1ObsType.FieldByName(fieldName)
		if !found {
			continue
		}

		code := generateObservationAssignment(fieldName, field.Type, v1Field.Type)
		if code != "" {
			data.ObservationFields = append(data.ObservationFields, code)
		}
	}
	// Generate UpToDate fields
	v1ParamType := reflect.TypeOf(v1alpha1.ApplicationSettingsParameters{})
	gitlabSettingsType := reflect.TypeOf(gitlab.Settings{})

	for i := 0; i < v1ParamType.NumField(); i++ {
		field := v1ParamType.Field(i)
		fieldName := field.Name

		// Find corresponding field in gitlab.Settings
		gitlabField, found := gitlabSettingsType.FieldByName(fieldName)
		if !found {
			continue
		}

		codeUpToDate := generateUpToDateCheck(fieldName, gitlabField.Type, field.Type)
		if codeUpToDate != "" {
			data.UpToDateFields = append(data.UpToDateFields, codeUpToDate)
		}

		codeLateInit := generateLateInitializeAssignment(fieldName, gitlabField.Type, field.Type)
		if codeLateInit != "" {
			data.LateInitializeFields = append(data.LateInitializeFields, codeLateInit)
		}
	}

	f, err := os.Create("generated_settings_converters.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	f.WriteString(outputHeader)
	funcTemplate.Execute(f, data)
}

func generateUpdateAssignment(fieldName string, gitlabType, v1Type reflect.Type) string {
	// Special case for DefaultBranchProtectionDefaults
	if fieldName == "DefaultBranchProtectionDefaults" {
		return fmt.Sprintf("o.%s = v1Alpha1DefaultBranchProtectionDefaultsOptionsPtrToGitlabBranchProtectionDefaults(p.%s)", fieldName, fieldName)
	}

	// Special case for RestrictedVisibilityLevels
	if fieldName == "RestrictedVisibilityLevels" {
		return fmt.Sprintf("o.%s = clients.StringPtrSliceToVisibilityValuePtrSlice(p.%s)", fieldName, fieldName)
	}

	// Check for VisibilityValue
	if gitlabType == reflect.TypeOf((*gitlab.VisibilityValue)(nil)) {
		return fmt.Sprintf("if p.%s != nil {\n\t\to.%s = clients.VisibilityValueStringToGitlab(*p.%s)\n\t}", fieldName, fieldName, fieldName)
	}

	// Check for *time.Time -> *time.Time
	if gitlabType.String() == "*time.Time" && v1Type.String() == "*v1.Time" {
		return fmt.Sprintf("o.%s = &p.%s.Time", fieldName, fieldName)
	}

	// Check for same types
	if gitlabType == v1Type {
		return fmt.Sprintf("o.%s = p.%s", fieldName, fieldName)
	}

	// Check for []string -> []string
	if gitlabType.Kind() == reflect.Slice && gitlabType.Elem().Kind() == reflect.String &&
		v1Type.Kind() == reflect.Slice && v1Type.Elem().Kind() == reflect.String {
		return fmt.Sprintf("o.%s = p.%s", fieldName, fieldName)
	}

	// Check for *int -> *int (even if different types like *int vs *int)
	if gitlabType.Kind() == reflect.Ptr && v1Type.Kind() == reflect.Ptr {
		if gitlabType.Elem().Kind() == v1Type.Elem().Kind() {
			return fmt.Sprintf("o.%s = p.%s", fieldName, fieldName)
		}
	}
	// No match found, needs manual handling
	return fmt.Sprintf("// TODO: Handle field %s (%s -> %s)", fieldName, v1Type, gitlabType)
}

func generateObservationAssignment(fieldName string, gitlabType, v1Type reflect.Type) string {
	// Special case for DefaultBranchProtectionDefaults
	if fieldName == "DefaultBranchProtectionDefaults" {
		return fmt.Sprintf("{\n\t\tval := gitlabBranchProtectionDefaultsTov1Alpha1BranchProtectionDefaults(g.%s)\n\t\to.%s = &val\n\t}", fieldName, fieldName)
	}

	// Special case for RestrictedVisibilityLevels
	if fieldName == "RestrictedVisibilityLevels" {
		return fmt.Sprintf("o.%s = clients.VisibilityValueSliceToStringSlice(g.%s)", fieldName, fieldName)
	}

	// Check for VisibilityValue (pointer)
	if gitlabType == reflect.TypeOf((*gitlab.VisibilityValue)(nil)) {
		return fmt.Sprintf("if g.%s != nil {\n\t\to.%s = string(*g.%s)\n\t}", fieldName, fieldName, fieldName)
	}

	// Check for VisibilityValue (value)
	if gitlabType == reflect.TypeOf(gitlab.VisibilityValue("")) {
		return fmt.Sprintf("o.%s = string(g.%s)", fieldName, fieldName)
	}

	// Check for *time.Time -> *metav1.Time
	if gitlabType.String() == "*time.Time" && strings.Contains(v1Type.String(), "Time") {
		return fmt.Sprintf("o.%s = clients.TimeToMetaTime(g.%s)", fieldName, fieldName)
	}

	// Check for same types
	if gitlabType == v1Type {
		return fmt.Sprintf("o.%s = g.%s", fieldName, fieldName)
	}

	// Check for *int -> int or int -> int
	if gitlabType.Kind() == v1Type.Kind() {
		return fmt.Sprintf("o.%s = g.%s", fieldName, fieldName)
	}

	return fmt.Sprintf("// TODO: Handle field %s (%s -> %s)", fieldName, gitlabType, v1Type)
}

func generateUpToDateCheck(fieldName string, gitlabType, v1Type reflect.Type) string {
	// Special case for DefaultBranchProtectionDefaults
	if fieldName == "DefaultBranchProtectionDefaults" {
		return fmt.Sprintf("\tif !isDefaultBranchProtectionDefaultsPtrEqualToDefaultsPtr(p.%s, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// Special case for RestrictedVisibilityLevels
	if fieldName == "RestrictedVisibilityLevels" {
		return fmt.Sprintf("\tif !clients.IsComparableSliceEqualToComparableSlicePtr(p.%s, clients.VisibilityValueSliceToStringSlice(g.%s)) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// Special case for ElasticsearchURL
	if fieldName == "ElasticsearchURL" {
		return fmt.Sprintf(`	if p.ElasticsearchURL != nil {
		// ElasticsearchURL is a comma separated string in gitlab
		splitUrls := strings.Split(*p.ElasticsearchURL, ",")
		if !clients.IsComparableSliceEqualToComparableSlicePtr(&splitUrls, g.ElasticsearchURL) {
			return false
		}
	}`)
	}

	// Check for VisibilityValue
	if gitlabType == reflect.TypeOf((*gitlab.VisibilityValue)(nil)) {
		return fmt.Sprintf("// TODO: Handle field %s (%s -> %s) - VisibilityValue pointer mismatch", fieldName, v1Type, gitlabType)
	}

	// Check for VisibilityValue (value)
	if gitlabType == reflect.TypeOf(gitlab.VisibilityValue("")) {
		// p is *string (in generated types)
		// g is gitlab.VisibilityValue (alias to string)
		// We can cast g to string.
		return fmt.Sprintf("if !clients.IsComparableEqualToComparablePtr(p.%s, string(g.%s)) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// Check for *v1.Time -> *time.Time
	if gitlabType.String() == "*time.Time" && v1Type.String() == "*v1.Time" {
		return fmt.Sprintf("if !clients.IsComparablePtrEqualToComparablePtr(&p.%s.Time, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// Check for same types (pointers)
	if gitlabType == v1Type && gitlabType.Kind() == reflect.Ptr {
		return fmt.Sprintf("if !clients.IsComparablePtrEqualToComparablePtr(p.%s, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// Check for *T -> T (Pointer vs Value)
	if v1Type.Kind() == reflect.Ptr && gitlabType.Kind() != reflect.Ptr {
		// Ensure not slice or map
		if v1Type.Elem().Kind() != reflect.Slice && v1Type.Elem().Kind() != reflect.Map {
			// Check if element types are compatible
			if v1Type.Elem().Kind() == gitlabType.Kind() || (v1Type.Elem().Kind() == reflect.String && gitlabType.Kind() == reflect.String) {
				return fmt.Sprintf("if !clients.IsComparableEqualToComparablePtr(p.%s, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
			}
		}
	}

	// Check for *[]T -> []T (Slice Pointer vs Slice)
	if v1Type.Kind() == reflect.Ptr && v1Type.Elem().Kind() == reflect.Slice && gitlabType.Kind() == reflect.Slice {
		// Check element types
		if v1Type.Elem().Elem().Kind() == gitlabType.Elem().Kind() {
			return fmt.Sprintf("if !clients.IsComparableSliceEqualToComparableSlicePtr(p.%s, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
		}
	}

	// Check for map pointers
	if v1Type.Kind() == reflect.Ptr && v1Type.Elem().Kind() == reflect.Map && gitlabType.Kind() == reflect.Map {
		return fmt.Sprintf("if !clients.IsMapStringToComparableEqualToMapStringToComparablePtr(p.%s, g.%s) {\n\t\treturn false\n\t}", fieldName, fieldName)
	}

	// No match found, needs manual handling
	return fmt.Sprintf("// TODO: Handle field %s (%s -> %s) - Type mismatch", fieldName, v1Type, gitlabType)
}

// generateLateInitializeAssignment generates late initialization code for a given field
func generateLateInitializeAssignment(fieldName string, gitlabType, v1Type reflect.Type) string {
	lateInitFromValueCode := fmt.Sprintf("in.%s = clients.LateInitializeFromValue(in.%s, settings.%s)", fieldName, fieldName, fieldName)

	// Special case for DefaultBranchProtectionDefaults
	if fieldName == "DefaultBranchProtectionDefaults" {
		return fmt.Sprintf("if in.%s == nil {\n\t\tval := gitlabBranchProtectionDefaultsTov1Alpha1BranchProtectionDefaultsOptions(settings.%s)\n\t\tin.%s = &val\n\t}", fieldName, fieldName, fieldName)
	}

	// Special case for RestrictedVisibilityLevels
	if fieldName == "RestrictedVisibilityLevels" {
		return fmt.Sprintf("if in.%s == nil {\n\t\tval := clients.VisibilityValueSliceToStringSlice(settings.%s)\n\t\tin.%s = &val\n\t}", fieldName, fieldName, fieldName)
	}

	// Check for VisibilityValue
	if gitlabType == reflect.TypeOf((*gitlab.VisibilityValue)(nil)) {
		return fmt.Sprintf("// TODO: Handle field %s (%s -> %s) - VisibilityValue pointer mismatch", fieldName, v1Type, gitlabType)
	}

	// Check for VisibilityValue (value)
	if gitlabType == reflect.TypeOf(gitlab.VisibilityValue("")) {
		return fmt.Sprintf("if in.%s == nil {\n\t\tval := string(settings.%s)\n\t\tin.%s = &val\n\t}", fieldName, fieldName, fieldName)
	}

	// Check for same types T -> T
	if gitlabType == v1Type {
		return fmt.Sprintf("in.%s = clients.LateInitialize(in.%s, settings.%s)", fieldName, fieldName, fieldName)
	}

	// Check for *v1.Time -> *time.Time
	if gitlabType.String() == "*time.Time" && v1Type.String() == "*v1.Time" {
		return fmt.Sprintf("in.%s = clients.LateInitialize(in.%s, clients.TimeToMetaTime(settings.%s))", fieldName, fieldName, fieldName)
	}

	// Check for pointer to value conversions
	if v1Type.Kind() == reflect.Ptr && gitlabType.Kind() != reflect.Ptr {
		if v1Type.Elem().Kind() == reflect.Slice && gitlabType.Kind() == reflect.Slice {
			if v1Type.Elem().Elem().Kind() == gitlabType.Elem().Kind() {
				return lateInitFromValueCode
			}
		} else if v1Type.Elem().Kind() == reflect.Map && gitlabType.Kind() == reflect.Map {
			return lateInitFromValueCode
		} else if v1Type.Elem().Kind() != reflect.Slice && v1Type.Elem().Kind() != reflect.Map {
			if v1Type.Elem().Kind() == gitlabType.Kind() || (v1Type.Elem().Kind() == reflect.String && gitlabType.Kind() == reflect.String) {
				return lateInitFromValueCode
			}
		}
	}

	// No match found, needs manual handling
	return fmt.Sprintf("// TODO: Handle field %s (%s -> %s) - Type mismatch", fieldName, v1Type, gitlabType)
}
