//go:build ignore
// +build ignore

/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generate ApplicationSettingsParameters and ApplicationSettingsObservation structs
//go:generate go run generate.go

package main

import (
	"fmt"
	"log"
	"os"
	"reflect"
	"strings"
	"time"
	"unicode"

	gitlab "gitlab.com/gitlab-org/api/client-go"
)

const outputHeader = `/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by generate.go. DO NOT EDIT.

//go:generate go run generate.go

// +kubebuilder:object:generate=true

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

`

func main() {
	out := &strings.Builder{}
	out.WriteString(outputHeader)

	// Generate ApplicationSettingsParameters
	out.WriteString("// ApplicationSettingsParameters defines the desired state for ApplicationSettings\n")
	out.WriteString("// This struct was generated from gitlab.UpdateSettingsOptions struct, with just a rework of the json tags.\n")
	generateStruct(out, "ApplicationSettingsParameters", reflect.TypeOf(gitlab.UpdateSettingsOptions{}))

	// Generate ApplicationSettingsObservation
	out.WriteString("// ApplicationSettingsObservation defines the observed state for ApplicationSettings\n")
	out.WriteString("// This struct was generated from gitlab.Settings struct, with just a rework of the json tags.\n")
	generateStruct(out, "ApplicationSettingsObservation", reflect.TypeOf(gitlab.Settings{}))

	if err := os.WriteFile("generated_settings_types.go", []byte(out.String()), 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Generated generated_settings_types.go")
}

func generateStruct(out *strings.Builder, name string, t reflect.Type) {
	out.WriteString(fmt.Sprintf("type %s struct {\n", name))
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fieldName := field.Name
		fieldType := field.Type

		// Skip unexported fields
		if len(fieldName) > 0 && unicode.IsLower([]rune(fieldName)[0]) {
			continue
		}

		goType := toGoType(fieldType)
		jsonTag := toCamelCase(fieldName)

		// Apply common acronym replacements to match existing style
		jsonTag = replaceAcronyms(jsonTag)

		// Add omitempty
		tag := fmt.Sprintf("`json:\"%s,omitempty\"`", jsonTag)

		out.WriteString(fmt.Sprintf("\t%s %s %s\n", fieldName, goType, tag))
	}
	out.WriteString("}\n\n")
}

func toGoType(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		return "*" + toGoType(t.Elem())
	}
	if t.Kind() == reflect.Slice {
		return "[]" + toGoType(t.Elem())
	}
	if t.Kind() == reflect.Map {
		return "map[" + toGoType(t.Key()) + "]" + toGoType(t.Elem())
	}

	typeName := t.String()
	// Convert time.Time to metav1.Time
	if t == reflect.TypeOf(time.Time{}) {
		return "metav1.Time"
	}

	// Convert gitlab.VisibilityValue to string
	if strings.HasSuffix(typeName, "VisibilityValue") {
		return "string"
	}
	// Convert gitlab.* types to local types
	if strings.HasPrefix(typeName, "gitlab.") {
		// Remove gitlab. prefix and assume local type exists
		return strings.TrimPrefix(typeName, "gitlab.")
	}
	return typeName
}

func toCamelCase(s string) string {
	if s == "" {
		return ""
	}
	runes := []rune(s)

	// Find the length of the initial uppercase sequence
	i := 0
	for i < len(runes) && unicode.IsUpper(runes[i]) {
		i++
	}

	// If the whole string is uppercase, lowercase it all
	if i == len(runes) {
		return strings.ToLower(s)
	}

	// If we have a sequence of uppercase letters
	if i > 1 {
		// If the character after the sequence is lowercase, we keep the last uppercase letter as the start of the next word
		// e.g. "XMLReader" -> "xmlReader" (i=3, runes[3]='R')
		// "ID" -> "id" (i=2, end of string)

		// Lowercase everything up to i-1
		for j := 0; j < i-1; j++ {
			runes[j] = unicode.ToLower(runes[j])
		}
		return string(runes)
	}

	// Just lowercase the first letter
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func replaceAcronyms(s string) string {
	replacements := []struct {
		old string
		new string
	}{
		{"ID", "Id"},
		{"URL", "Url"},
		{"API", "Api"},
		{"TTL", "Ttl"},
		{"CIDR", "Cidr"},
		{"DNS", "Dns"},
		{"TLS", "Tls"},
		{"SSH", "Ssh"},
		{"GPG", "Gpg"},
		{"RSA", "Rsa"},
		{"ECDSA", "Ecdsa"},
		{"ED25519", "Ed25519"},
		{"AWS", "Aws"},
		{"EKS", "Eks"},
		{"HTML", "Html"},
		{"LDAP", "Ldap"},
		{"NPM", "Npm"},
		{"YAML", "Yaml"},
		{"CN", "Cn"},
		{"IP", "Ip"},
	}

	for _, r := range replacements {
		s = strings.ReplaceAll(s, r.old, r.new)
	}
	return s
}
