package main

import (
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	if len(os.Args) > 1 && os.Args[1] == "restore-referencers" {
		if err := restoreReferencers(); err != nil {
			fmt.Fprintf(os.Stderr, "Error restoring referencers: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Successfully restored referencers files")
		return
	}

	if len(os.Args) > 1 && os.Args[1] == "backup-referencers" {
		if err := backupReferencers(); err != nil {
			fmt.Fprintf(os.Stderr, "Error backing up referencers: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Successfully backed up referencers files")
		return
	}

	var folders []string
	if len(os.Args) > 1 {
		folders = os.Args[1:]
	} else {
		// Default folders if none specified (excluding common since it's shared)
		folders = []string{"groups", "projects"}
	}

	if err := generateClusterAPIs(folders); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Successfully generated cluster APIs from namespaced APIs for folders: %v\n", folders)
}

func generateClusterAPIs(folders []string) error {
	// Determine the correct paths based on current working directory
	namespacedPath := "apis/namespaced"
	clusterPath := "apis/cluster"

	// If we're already in the apis directory, adjust paths
	if _, err := os.Stat("namespaced"); err == nil {
		namespacedPath = "namespaced"
		clusterPath = "cluster"
	}

	// Check if namespaced directory exists
	if _, err := os.Stat(namespacedPath); os.IsNotExist(err) {
		return fmt.Errorf("namespaced directory does not exist at %s", namespacedPath)
	}

	// Create cluster directory if it doesn't exist
	if err := os.MkdirAll(clusterPath, 0755); err != nil {
		return fmt.Errorf("failed to create cluster directory: %w", err)
	}

	// Remove existing folders that will be regenerated
	for _, folder := range folders {
		targetFolder := filepath.Join(clusterPath, folder)
		if err := os.RemoveAll(targetFolder); err != nil && !os.IsNotExist(err) {
			return fmt.Errorf("failed to remove cluster folder %s: %w", targetFolder, err)
		}
	}

	// Process each specified folder
	for _, folder := range folders {
		folderPath := filepath.Join(namespacedPath, folder)
		if _, err := os.Stat(folderPath); os.IsNotExist(err) {
			fmt.Printf("Warning: folder %s does not exist, skipping\n", folderPath)
			continue
		}

		// Walk through the specific folder
		err := filepath.WalkDir(folderPath, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}

			// Skip v1beta1 folder as requested
			if strings.Contains(path, "v1beta1") {
				if d.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}

			// Skip generated files
			if strings.HasPrefix(d.Name(), "zz_") {
				return nil
			}

			// Calculate target path
			targetPath := strings.Replace(path, namespacedPath, clusterPath, 1)

			if d.IsDir() {
				return os.MkdirAll(targetPath, 0755)
			}

			// Only process .go files
			if !strings.HasSuffix(path, ".go") {
				return nil
			}

			// Add zz_ prefix to filename
			dir := filepath.Dir(targetPath)
			filename := filepath.Base(targetPath)
			targetPath = filepath.Join(dir, "zz_"+filename)

			return transformFile(path, targetPath)
		})

		if err != nil {
			return fmt.Errorf("failed to process folder %s: %w", folder, err)
		}
	}

	return nil
}

func transformFile(srcPath, dstPath string) error {
	content, err := os.ReadFile(srcPath)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", srcPath, err)
	}

	transformed := transformContent(string(content))

	// Format the Go code
	formatted, err := format.Source([]byte(transformed))
	if err != nil {
		// If formatting fails, use the unformatted version
		formatted = []byte(transformed)
	}

	if err := os.WriteFile(dstPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", dstPath, err)
	}

	return nil
}

func transformContent(content string) string {
	// Add code generation comment before package statement
	lines := strings.Split(content, "\n")
	var result []string
	packageFound := false

	for _, line := range lines {
		if !packageFound && strings.HasPrefix(strings.TrimSpace(line), "package ") {
			result = append(result, "// Code generated by hack/generate-cluster-scope.go - DO NOT EDIT.")
			result = append(result, "")
			packageFound = true
		}
		result = append(result, line)
	}
	content = strings.Join(result, "\n")

	// API group transformations
	content = strings.ReplaceAll(content, "gitlab.m.crossplane.io", "gitlab.crossplane.io")
	content = strings.ReplaceAll(content, "common.gitlab.m.crossplane.io", "common.gitlab.crossplane.io")
	content = strings.ReplaceAll(content, "groups.gitlab.m.crossplane.io", "groups.gitlab.crossplane.io")
	content = strings.ReplaceAll(content, "projects.gitlab.m.crossplane.io", "projects.gitlab.crossplane.io")

	// Import path transformations
	content = strings.ReplaceAll(content, "apis/namespaced/", "apis/cluster/")

	// Resource spec transformations
	content = strings.ReplaceAll(content, "xpv2.ManagedResourceSpec", "xpv1.ResourceSpec")

	// Reference type transformations
	content = strings.ReplaceAll(content, "xpv1.NamespacedReference", "xpv1.Reference")
	content = strings.ReplaceAll(content, "xpv1.NamespacedSelector", "xpv1.Selector")

	// Resolver transformations
	content = strings.ReplaceAll(content, "reference.NewAPINamespacedResolver", "reference.NewAPIResolver")
	content = strings.ReplaceAll(content, "reference.NamespacedResolutionRequest", "reference.ResolutionRequest")
	content = strings.ReplaceAll(content, "reference.NamespacedResolutionResponse", "reference.ResolutionResponse")

	// Kubebuilder scope transformations
	content = strings.ReplaceAll(content, "kubebuilder:resource:scope=Namespaced", "kubebuilder:resource:scope=Cluster")

	// Filter out unwanted lines
	lines = strings.Split(content, "\n")
	var filteredLines []string
	inImportBlock := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Track import blocks
		if strings.HasPrefix(trimmed, "import (") {
			inImportBlock = true
		} else if inImportBlock && trimmed == ")" {
			inImportBlock = false
		}

		// Skip v1beta1 imports and references
		if strings.Contains(line, "apis/cluster/v1beta1") ||
			strings.Contains(line, "gitlabv1beta1") ||
			(inImportBlock && strings.Contains(line, "v1beta1")) {
			continue
		}

		// Skip xpv2 import since we replaced all usages
		if inImportBlock && strings.Contains(line, `xpv2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"`) {
			continue
		}

		filteredLines = append(filteredLines, line)
	}

	return strings.Join(filteredLines, "\n")
}

func backupReferencers() error {
	return filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return nil // ignore errors
		}
		if strings.HasSuffix(path, "referencers.go") && !strings.HasSuffix(path, ".bak") {
			return os.Rename(path, path+".bak")
		}
		return nil
	})
}

func restoreReferencers() error {
	return filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return nil // ignore errors
		}
		if strings.HasSuffix(path, "referencers.go.bak") {
			newPath := strings.TrimSuffix(path, ".bak")
			return os.Rename(path, newPath)
		}
		return nil
	})
}
